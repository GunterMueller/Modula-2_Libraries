(*$Copyright 1988 by Olsen & Associates (O&A), Zurich, Switzerland.

                       All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies, and
that both that copyright notice and this permission notice appear in
supporting documentation, and that all modifications of this software
or its documentation not made by O&A or its agents are accompanied
by a prominent notice stating who made the modifications and the date
of the modifications.

O&A DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE AND ITS
DOCUMENTATION, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS.  IN NO EVENT SHALL O&A BE LIABLE FOR ANY SPECIAL, INDIRECT OR
CONSEQUENTIAL DAMAGES, ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE OR ITS DOCUMENTATION.
******************)

DEFINITION MODULE TextIO;
(*
 * Supports text file input/output. The file object exported by this
 * module is treated as a sequence of lines with each line containing
 * a sequence of characters. A line may be terminated by reaching the
 * end-of-file or by an explicit line break separator whose syntax is
 * not exported in order to increase the portability of this module.
 *)
IMPORT 
    IOConsts,
    IOErrors,
    SYSTEM,
    SysTypes;
EXPORT QUALIFIED
    Object,		States,		DONTCARE,	Modes,
    defaultOptions,	Open,		BufferingModes,	maxOptionsLength,
    Options,		MakeOptions,	Close,		SetInvalid,
    Read,		ReadChars,	ReadLn,		UndoRead,
    ScannerProc, 	ScanModes,	Scan,		Write,		
    WriteChars, 	WriteLn,
    Flush,		Rewind,		Append,		RewindAndTruncate,
    GetState,	        GetError,
    SetError,		GetOpenPath,	GetMode,	PrintErrorMessage,
    IsInteractive,	GetInput,	GetOutput,	GetErrorOutput,
    SetInput,		SetOutput,	SetErrorOutput;

TYPE
    Object;
    (*
     * Identifies an open file.
     *)

TYPE
    States = ( 
        ok,         (* previous read/write operation was successful *)
        endOfFile,  (* end-of-file was encountered on last read operation *)
        endOfLine,  (* end-of-line was encountered on last read operation *)
        error       (* the last operation failed *)
    );
    (*
     * The state parameter returned by the procedures in this module
     * will reflect the value returned by GetState (the only exception
     * is the Close procedure).
     *
     * "endOfFile":
     *     If the file is in the "endOfFile" state and a ReadXXX
     *     procedure is called, the file will be put in an "error"
     *     state with the error being "IOErrors.readPastEOF".  
     *
     *     If "endOfFile" is returned by a Read procedure, the operation 
     *     failed (no data was read or is returned).
     *
     * "endOfLine":
     *     The state "endOfLine" signifies that a line separator has been
     *     read. It means that the previous read failed as a result of
     *     finding an "endOfLine". If GetState returns "endOfLine", it is
     *     legal to call a ReadXXX routine, and the first character to be
     *     read will be the first character on the new line of text. Thus,
     *     no special calls (such as ReadLn) are required to skip beyond
     *     an "endOfLine" condition: any subsequent read will start on
     *     the next line.
     *
     *     If "endOfLine" is returned by a Read procedure, the operation 
     *     failed (no data was read or is returned).
     *
     * "error":
     *     If a file is in the "error" state and any of the Read, Write,
     *     or Flush or UndoRead procedures are called, the caller will
     *     be terminated.
     *
     *     If a procedure returns "error", the other output parameters
     *     associated with the call are invalid.
     *)
VAR
    DONTCARE : States;
    (*
     * Garbage can, don't use for other purposes.
     *)

TYPE
    Modes = ( 
        readOnly,   (* only reads are legal *)
        appendOnly  (* only writes are legal and start at end-of-file *)
    );
    (*
     * The error "IOErrors.illegalOp" will occur if you attempt to
     * write to a "readOnly" file, or read and "appendOnly" file.
     *)

CONST
    defaultOptions = '';
    (*
     * Use the default set of options.
     * Both the constant and the empty string are portable.
     *)

PROCEDURE Open(
    VAR file    : Object;           (* associated with the external file *)
        path    : ARRAY OF CHAR;    (* external file to be opened *)
        mode    : Modes;            (* the type of access requested *)
        options : ARRAY OF CHAR     (* empty or generated by MakeOptions *)
    )           : IOErrors.Errors;  (* IOErrors.ok => file opened *)
    (*
     * Initialize the file object with the external file identified
     * by the "path" string.
     *
     * The options string is used to specify non-portable options.
     * "defaultOptions" or '' are the only portable values for this
     * parameter. See the procedure MakeOptions for a specification
     * of this implementation's local options.
     *)

(*
 * Options are always IMPLEMENTATION SPECIFIC, thus all of the following
 * declarations are non-portable.
 *)
TYPE
    BufferingModes = (
        doNotBuffer,  (* send/get data directly to/from BinaryIO *)
        doBuffering   (* hold characters in buffer before sending/getting *)
    );
CONST
    maxOptionsLength = 2;
TYPE
    Options = ARRAY[ 0 .. maxOptionsLength - 1 ] OF CHAR;

PROCEDURE MakeOptions(
        howToBuffer   : BufferingModes;  (* should writes be buffered *)
        binaryOptions : ARRAY OF CHAR;   (* passed to BinaryIO.Open *)
    VAR result        : ARRAY OF CHAR    (* combination of inputs *)
    );
    (*
     * An options string is a combination of dynamically interpreted
     * values. In this implementation, BinaryIO is used as the underlying
     * file access media.
     *
     * If you just want to set BinaryIO options, you don't need to call
     * this procedure. If there are no BinaryIO (or BinaryIO class)
     * options, the value "defaultOptions" or '' may be used.
     *
     * buffering:
     *     With this procedure you can decide whether buffering is used
     *     or not. The default mode is to buffer for non-interactive
     *     files and not to buffer for interactive files. The choice of
     *     buffering depends upon the application. Note that this option
     *     may be used only if the file is being opened in "appendOnly"
     *     mode. Also note that ErrorOutput is always unbuffered.
     *
     * "result":
     *     The result string is a combination of the BufferingModes plus
     *     the "binaryOptions" passed in.
     *
     *     If result is smaller than the length of "binaryOptions" plus
     *     the "maxOptionsLength", the caller will be terminated. This
     *     means that if you want to have both TextIO and BinaryIO specific
     *     options, you will have to declare a string of the appropriate
     *     length. See BinaryIO for the maximum length of its options.
     *)

PROCEDURE Close(
    VAR file : Object            (* may be in any state, will be invalid *)
    )        : IOErrors.Errors;  (* IOErrors.ok => file closed *)
    (*
     * Attempt to flush internal buffers and dissociate "file"
     * with the external file, and close the external file.
     *
     * Errors occurring during attempted flush are returned but
     * do not cause premature termination of the Close.
     *)

PROCEDURE SetInvalid(
    VAR file : Object  (* will be invalid *)
    );
    (*   
     * Initializes the file variable to an invalid object.
     * This procedure allows an importer to properly initialize
     * all data structures without actually creating spaces.
     *)

PROCEDURE Read(
        file   : Object;  (* not in "error" state and readable *)
    VAR toRead : CHAR     (* character read (if ok) *)
    )          : States;  (* ok => character read *)
    (*
     * Read a character from "file".
     *)
    
PROCEDURE ReadChars(
        file      : Object;          (* in "ok" state and readable *)
        buf       : SYSTEM.ADDRESS;  (* POINTER TO ARRAY OF CHAR *)
        bufSize   : SysTypes.Card;   (* maximum number of chars to read *)
    VAR charsRead : SysTypes.Card    (* actual number of chars read *)
    )             : States;          (* see States *)
    (*
     * Fill location in memory pointed to by "buf" with data
     * read from file.  Note this procedure treats "buf" as a character 
     * array and should not be confused with BinaryIO.ReadBytes.
     *
     * NOTE: This procedure does not conform to the other Read procedures
     *       in this module or to other modules in the TextIO family.  The
     *	     States return value does not govern the number of chars read:
     * 	     that is, this procedure does not "fail" if the state is not "ok".
     * 	     Therefore, charsRead will always reflect the number of chars
     * 	     read from the file, regardless of the file state.
     *)

PROCEDURE ReadLn(
    file : Object   (* in "ok" or "endOfLine" state and readable *)
    )    : States;  (* ok => new-line read *)
    (*
     * While state is not "endOfLine", characters are read from "file" 
     * until a line break is encountered. After this no more characters
     * are read and the file state is set to "ok". The characters read
     * are discarded.
     *) 

PROCEDURE UndoRead(
    file : Object   (* not in "error" state and readable *)
    )    : States;  (* error => problem restoring previous read *)
    (*
     * Restore the state of the file to that which existed prior to
     * the previous character read.
     *
     * - If the file's state was "endOfLine" or "endOfFile", then reset
     * the state to "ok" and the next read will fail.
     * - If the previous operation was a successful ReadLn, then the next
     * read will fail as a result of "endOfLine" being read.
     * - If the file's state is "ok", then put the last character read
     * from the file back on the input stream. 
     *
     * This operation will fail if it immediately follows calls to one of
     * UndoRead Rewind, or Open, and these failures will be indicated as
     * "IOErrors.illegalOp".
     *
     * Higher-level formatIO routines such as ReadString may take advantages
     * of this procedure, therefore one should not call it just after calls
     * to these procedures.
     *)

TYPE
    ScannerProc = PROCEDURE(
        SysTypes.ANYPTR, (* importerObject passed through unmodified *)
        CHAR             (* value read from the file *)
    ) : BOOLEAN;         (* keep going? *)
    (*
     * Is given a character read from the file along with its importerObject.
     * If endOfLine or endOfFile is encountered, this procedure will not
     * be called and the scan will be terminated. If this procedure returns
     * FALSE, the scan is terminated and the character passed to ScannerProc
     * is "undone" so that a subsequent read (or scan) will pick it up.
     * To keep scanning, this procedure must return TRUE.
     *)

    ScanModes = (
        doNotSkip,             (* first character read is passed *)
        skipLeadingWhiteSpace  (* leading white space is ignored *)
    );

PROCEDURE Scan(
    file           : Object;          (* "ok" or "endOfLine" and readable *)
    scanner        : ScannerProc;     (* procedure called with chars read *)
    importerObject : SysTypes.ANYPTR; (* passed unmodified to scanner *)
    scanMode       : ScanModes        (* ignore leading white space? *)
    )              : States;          (* ok => scanned, see comments *)
    (*
     * Provides a high level mechanism for scanning characters in a 
     * line: a scanner is called for each character read in the file.
     *
     * "scanner":
     *     The character can be processed based on information inside
     *     of importerObject (which it is free to define).
     *
     *     The scanner is not allowed to call any procedures which
     *     modify the file state except SetError. The GetXXX and
     *     PrintErrorMessage procedures may be called. All other calls
     *     will cause the file to be entered into an "error" state. If
     *     the caller sets the file state to "error" and the scanner
     *     does not return FALSE, the caller will be terminated.
     *
     *     The scan will terminate if the scanner returns FALSE and the
     *     last character passed will be undone (otherwise, the scan will
     *     terminate if either "endOfLine", "endOfFile", or an error in
     *     the file is encountered).
     *
     * scanMode:
     *     The scanner will be called with the first non-white space
     *     character (as defined in module Chars) on the line, if
     *     "skipLeadingWhiteSpace" is the scanMode. Otherwise, scanner
     *     is given the first character read.
     *
     * "endOfLine" & "endOfFile":
     *     If "endOfLine" or "endOfFile" is encountered before scanner
     *     is called (if "skipLeadingWhiteSpace", this means before a
     *     non-white space), then this state will be returned. If either
     *     of these states is encountered after scanner has been called,
     *     then this procedure will "undo" the state and return "ok".
     *
     * Recursive scans are not allowed.
     *)

PROCEDURE Write(
    file    : Object;  (* not in "error" state and writable *)
    toWrite : CHAR     (* character to be written *)
    )       : States;  (* ok => character written *)
    (*
     * Write the character to the file.
     *)

PROCEDURE WriteChars(
        file    : Object;          (* not in "error" state and writable *)
        buf     : SYSTEM.ADDRESS;  (* POINTER TO ARRAY OF CHAR *)
        bufSize : SysTypes.Card    (* number of chars to be written *)
    )           : States;          (* ok => data written *)
    (*
     * Write "bufSize" worth of "buf" data to "file".  Note that this
     * procedure treats "buf" as a character array and should not be
     * confused with BinaryIO.WriteBytes.
     *)

PROCEDURE WriteLn(
    file : Object   (*  in "ok" state and writable *)
    )    : States;  (*  ok => new-line written *)
    (*
     * Put a new line into the file (i. e. the next character written to
     * this file will appear as the first character on the next line).
     *)

PROCEDURE Flush(
    file : Object   (* not in "error" state and writable *)
    )    : States;  (* error => problem writing buffers *)
    (*
     * Write any buffers to the external file object to guarantee
     * consistency (only for "appendOnly" files).
     *
     * DOS IMPLEMENTATION SPECIFIC NOTE: 
     *     Attempts to Flush the initial standard files will fail, because
     *     Flush requires the file's name and this is unavailable for the
     *     initial standard input, output, and error output.
     *) 

PROCEDURE Rewind(
    file : Object   (* not in "error" state *)
    )    : States;  (* ok => rewound and readOnly *)
    (*
     * Position the file at its start. If in readOnly mode the file
     * will then be re-read from the start. If in appendOnly mode the
     * mode will be changed to readOnly, after which a normal Rewind
     * will be performed.
     *
     * Note that appendOnly rewinds may be restricted by the access to
     * the file. If the file access is not permitted, then an error
     * will be returned which may be reset via SetError.
     *
     * UndoReads are illegal immediately after a call to Rewind.
     *)

PROCEDURE Append( 
    file : Object  (* not in "error" state *)
    )    : States; (* ok => file is at end and appendOnly *)
    (*
     * Position the file at its end and changes the mode to appendOnly. 
     * If in appendOnly mode then this is effectively a no-op.  If in 
     * readOnly mode the mode will be changed to appendOnly and the
     * file position will be positioned to the end.
     *
     * Note that readOnly appends may be restricted by the access to
     * the file. If the file access is not permitted, then an error
     * will be returned which may be reset via SetError.
     *)

PROCEDURE RewindAndTruncate( 
    file : Object  (* not in "error" state *)
    )    : States; (* ok => file is empty and appendOnly *)
    (*
     * Position the file at its beginning and zeroes the file (removes
     * all data).  The mode of the file is then changed to appendOnly.
     * This operation is difficult and therefore it may not be available
     * for all files.
     *
     * If readOnly operation may be restricted by the access to
     * the file. If the file access is not permitted, then an error
     * will be returned which may be reset via SetError.
     *)

PROCEDURE GetState(
    file : Object   (* must be valid *)
    )    : States;  (* current state of "file" *)

PROCEDURE GetError(
    file : Object            (* must be valid *)
    )    : IOErrors.Errors;  (* error code for "file" *)

PROCEDURE SetError(
    file     : Object;          (* must be valid *)
    newError : IOErrors.Errors  (* what to set the internal error value to *)
    )        : States;          (* see comment *)
    (*
     * This procedure provides a means for changing/resetting the file's
     * error state and value. It does not actually modify the external
     * file object, but allows the caller to indicate an error by changing
     * the file to an error state or to retry operations by resetting the
     * state of the file.
     *
     * If the newError is "IOErrors.ok" and the call is successful, then the
     * state of the file will change to what it was before the file was
     * in the error state. If the newError is not "IOErrors.ok", then the
     * state of the file will always be "error" after this call.  
     *
     * Failure in all cases is indicated if both conditions are true:
     *    - the file is in an error state after the call, and
     *    - calling GetError yields something other than "newError"
     *
     * The "error" code will be returned if the file's error value is
     * not "IOErrors.ok" (the file is in an error state).
     *)

PROCEDURE PrintErrorMessage(
    file    : Object;        (* for which info is to be printed *)
    message : ARRAY OF CHAR  (* what is to be printed, if empty use state *)
    );
    (* 
     * Print an error message to ProgErrOutput.
     *
     * The message consists of the "message" and path, but the
     * exact format of this message is implementation specific.
     *
     * If "message" is empty, then the IOErrors.ToString of the
     * current error state will be used.
     *)

PROCEDURE GetOpenPath(
        file : Object;        (* must be valid *)
    VAR path : IOConsts.Path  (* path of external file, or empty *)
    );
    (*
     * Returns the path of the file exactly as specified by the caller
     * to the Open routine.  
     *
     * This may not be an absolute file name. If the default directory has
     * been changed, the path may thus not point to the name of the file.
     *)

PROCEDURE GetMode(
    file : Object  (* must be valid *)
    )    : Modes;  (* read or writing? (NB: Append & Rewind change mode) *)
    (*
     * Note that the procedures Append and Rewind can change the
     * the "mode" of a file.
     *)


PROCEDURE IsInteractive(
    file : Object    (* must be valid *)
    )    : BOOLEAN;  (* TRUE => is interactive *)
    (*
     * This procedure specifies whether the file is "interactive".
     * The exact definition is very implementation specific.
     *)

(*
 * Start of routines to allow redirection of the default (standard)
 * input/output files. These files (Input, Output, and ErrorOutput)
 * are initialized to implementation specific values and may be
 * changed at any point during the program's execution.
 *
 * Tasks NOTE:
 *    If light weight processes are being used with this library, the
 *    default IO objects must be protected by mutual exclusion. The
 *    monitors are provided for this purpose. Any direct use of these
 *    variables must be surrounded by calls to TaskMonitors.Enter/Exit.
 *    The Set/Get routines have been properly protected.
 *)

PROCEDURE GetInput(
    ) : Object;  (* is "readOnly" *)
    (*
     * Get the default (standard) input-file.
     *)

PROCEDURE GetOutput(
    ) : Object;  (* is "appendOnly" *)
    (*
     * Get the default (standard) output-file.
     *)

PROCEDURE GetErrorOutput(
    ) : Object;  (* is "appendOnly" *)
    (*
     * Get the default (standard) error output-file.
     *)

PROCEDURE SetInput(
    file : Object   (* not in "error" state and "readOnly" *)
    )    : States;  (* error => input NOT set *)
    (*
     * Set the default (standard) input-file.
     *)

PROCEDURE SetOutput(
    file : Object   (* not in "error" state and "appendOnly" *)
    )    : States;  (* error => output NOT set *)
    (*
     * Set the default (standard) output-file.
     *)

PROCEDURE SetErrorOutput(
    file : Object   (* not in "error" state and "appendOnly" *)
    )    : States;  (* error => error output NOT set *)
    (*
     * Set the default (standard) error output-file.
     *)

END TextIO.


