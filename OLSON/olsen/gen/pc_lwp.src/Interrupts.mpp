(*$Copyright 1988 by Olsen & Associates (O&A), Zurich, Switzerland.

                       All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies, and
that both that copyright notice and this permission notice appear in
supporting documentation, and that all modifications of this software
or its documentation not made by O&A or its agents are accompanied
by a prominent notice stating who made the modifications and the date
of the modifications.

O&A DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE AND ITS
DOCUMENTATION, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS.  IN NO EVENT SHALL O&A BE LIABLE FOR ANY SPECIAL, INDIRECT OR
CONSEQUENTIAL DAMAGES, ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE OR ITS DOCUMENTATION.
******************)

IMPLEMENTATION MODULE Interrupts;
(*
 * An interrupt handler is a two part sequence.  The importers of this
 * module supply the main thread as Modula procedure.  This module
 * provides the "dressing" around the thread.  We call this the Envelope.
 * Most of the code in this module is involved with setting up the interrupt
 * handler (see SetupEnvelope).
 *
 * AddressCheck:
 * This is used only when you are unsure of the addressing mechanisms
 * in the particular version of the compiler.
 *
 * Stacks:
 * We have to be very careful in the envelope, because DOS runs from its
 * own stack.  We switch stacks to a clean stack for the interrupt handler.
 * We save both the SP and SS when we save a context, so being inside
 * DOS shouldn't matter.  DOS should have enough room to save a couple of
 * registers on the stack.  It advertises that you should allow 80H bytes
 * on the stack for interrupt handlers.  
 *
 * It turns out that the BIOS has nested interrupts of the same type
 * (e.g. the keyboard).  Given this fact, we only have one interrupt
 * stack which is large enough for several interrupt saves.  This is
 * the traditional "kernel" approach and it saves the tasks from having
 * lots of space for interrupts on their stacks.  The hardest part is
 * checking to see if you are already running on the interrupt stack.
 *
 * Special interrupts ("upcalls" from DOS):
 * DOS has "upcalls".  This is problems, because the "upcalls" can cause
 * program termination.  They are executed on a special DOS stack and
 * DOS is in a critical section at this point.  The tasking system is
 * very delicate when there are interrupt handlers are installed and it
 * is fairly imperative that we not allow DOS to terminate the program
 * in this manner.  The only DOS upcalls are ctrl-break address and critical
 * error handler.  The critical error handler usually allows the user to
 * respond to error situations because the programs are not written 
 * properly.  The portable library catches all "failure" conditions,
 * thus a program will terminate if the errors are not handled properly.
 *
 * The other handler ctrl-break causes the program to terminate.  The
 * run-time system catches this error and if this module is not installed,
 * it causes the program to terminate.  However, we might have been inside
 * DOS when we got the ctrl-break, thus we can't just terminate.  We catch
 * it, set a flag, and ready the ``deathTask'' which polls the flag.
 * We can then terminate in the deathTask without fear of bad states.
 * This interrupt is not chained and may be replaced by TaskDebug.
 *
 * There is a bug in the BIOS which requires us to install a ``protective''
 * handler around keyboard interrupts.  Since we ready a task which
 * will be ready to run inside the ctrl-break interrupt handler, we must
 * protect the interrupt fully, that is, keep preemption disallowed for
 * the entire keyboard interrupt.  This slows down keyboard interrupts
 * a bit, but they don't happen so frequently and we must be careful.
 *
 * Restoring Interrupts:
 * When the system terminates, we need to restore the interrupt handlers
 * back to their origninal state at the request of Tasks.  This may 
 * occur before the interrupt handlers have been destroyed.  The result
 * is that we need to keep track of whether the vectors for the interrupt 
 * handlers have been installed or not.
 *
 * Note that destroys may occur in any order, thus we must be very
 * careful to do the "right thing" if out of order destroy occurs.
 * See Destroy for more details.
 *
 * ASSUMES:
 *     intStackTop is saved in the stack base.
 *)
IMPORT
    DOS,
    I8086,
    Notices,
    Objects,
    ProgErr,
    SafeStorage,
    SYSTEM,
    SysTypes,
    TaskConsts,
    TasksPRIVATE;

IMPORT
    Tasks;	(* This is imported to ensure initialization order
		   as specified in TasksPRIVATE. *)

CONST
    moduleName = "Interrupts";

CONST
    destroyConfusedMsg = 
	"Interrupts.Destroy: the list of interrupt handlers is munged.";
    createDuringTerminateMsg =
	"Interrupts.Create attempted after all handlers restored.";
    illegalRegisterMsg = 
	"Interrupts: illegal register change attempted.";
    addressingErrMsg = 
	"Interrupts: addressing problems, cannot initialize.";

CONST
    keyboardInt = 09H;
    dosCtrlBreakInt = 1BH;
    biosCtrlBreakInt = 1BH;

TYPE
    Offset = SysTypes.CARDINAL16;
TYPE
    Object    = POINTER TO ObjectRec;
VAR
    objectMgr : Objects.Manager;
    root      : Object;		
	(* 
	 * List of all interrupts sorted from lowest to highest vector
	 * numbers.  Where there are duplicates, the oldest comes first.
	 * Mutex: SYSTEM.DISABLE/ENABLE.
	 *)
    restored  : BOOLEAN;	
	(* 
	 * This variable is set to true when RestoreInterrupts is called.
	 * If it is true, then "root" is no longer valid and you don't
	 * need to restore interrupt handlers in destroy.
	 *)

CONST
    realStackSize = TaskConsts.minStackSize * 4; (* Some large number *)

VAR
    realStack  : SysTypes.SAUPTR;    	  (* Allocated address *)
    stackSize  : TaskConsts.StackSizes;	  (* After adjustment *)
    stack      : TasksPRIVATE.StackBase;
	(*
	 * This stack is shared between all interrupt handlers.
	 * It is a properly normalized address.
	 *)

PROCEDURE EmptyHandler(
    DONTCARE : SysTypes.ANYPTR
    );
    END EmptyHandler;	(* Not actually called *)

(*
 * The preamble and epilogue of the interrupt handlers are contained
 * in the Envelope defined below.  The first thing to execute when
 * an interrupt occurs is a customized envelope.  The following
 * section of code allows the envelope to be established simply and
 * easily.
 *)

CONST
    @IF LogitechM2V2 AND Debug THEN
	maxEnvelopeSize = 173;	
    @ELSE
	maxEnvelopeSize = 152;	
    @END
	(* 
	 * As much needed by SetupEnvelope. You can use "grep" and "dc" to 
         * figure out this number fairly easily.  Just do the following:
	 * 	% cp Insert Interrupts.mpp > temp 
	 *	% vi temp
	 *	:/^DO NOT REMOVE THIS SECOND MARK$/,$d
	 *	:g/InsertByte/s/.*/1 +/
	 *	:g/InsertCard/s/.*/2 +/
	 *	:g/InsertAdr/s/.*/4 +/
	 *	:1,/^DO NOT REMOVE THIS FIRST MARK$/d
	 *	% m2pp [Options] temp | grep '^[0-9]' | dc
	 * 	should print the result.
	 * This is approximate, but pretty close enough.
	 *)
TYPE
    EnvelopeIndex = [ 0 .. maxEnvelopeSize ];
    Envelope      = ARRAY EnvelopeIndex OF SYSTEM.BYTE;


PROCEDURE InsertAdr(
    VAR envelope : Envelope;
    VAR index    : EnvelopeIndex;
	adr      : SYSTEM.ADDRESS
    );
    (*
     * On the IP, low byte is first and high byte is last.
     *)
    BEGIN (* InsertAdr *)
	
	WITH adr DO
	    envelope[ index ] := SYSTEM.BYTE( CHR( OFFSET MOD 100H ) );
	    INC( index );
	    envelope[ index ] := SYSTEM.BYTE( CHR( OFFSET DIV 100H ) );
	    INC( index );

	    envelope[ index ] := SYSTEM.BYTE( CHR( SEGMENT MOD 100H ) );
	    INC( index );
	    envelope[ index ] := SYSTEM.BYTE( CHR( SEGMENT DIV 100H ) );
	    INC( index );
	END; (* WITH *)

    END InsertAdr;

TYPE
    ObjectRec = RECORD
	next		 : Object;	   (* newer or higher vector number  *)
	vector           : SysTypes.Card;  (* interrupt number *)
	prevThread       : SYSTEM.ADDRESS; (* previously installed in vector *)
	envelope         : Envelope; 	   (* Preamble/Epilogue code *)
    END; (* ObjectRec *)

VAR
    readyQueueAdr      : SYSTEM.ADDRESS;  (* ADR( readyQueue ) *)
    runningAdr         : SYSTEM.ADDRESS;  (* ADR( running ) *)
    offsetStackBase    : Offset;	  (* offset into TasksPR*.ObjectRec *)
    offsetIntStackTop  : Offset;	  (* offset into TasksPR*.StackBase *)
    @IF LogitechM2V2 AND Debug THEN
	offsetLogitechBP : Offset;  (* TasksPR*.ObjectRec.logitech.BP *)
	offsetLogitechCS : Offset;  (* TasksPR*.ObjectRec.logitech.CS *)
	offsetLogitechIP : Offset;  (* TasksPR*.ObjectRec.logitech.IP *)
	offsetSavedBP    : Offset;  (* intStackTop.savedBP *)
	offsetSavedCS    : Offset;  (* intStackTop.savedCS *)
	offsetSavedIP    : Offset;  (* intStackTop.savedIP *)
    @END (* Debug *)
    preemptionLevelAdr : SYSTEM.ADDRESS;  (* ADR( preemptionLevel ) *)

PROCEDURE SetupEnvelope( 
    VAR envelope       : Envelope;
	thread         : HandlerProc;
	importerObject : SysTypes.ANYPTR;
	afterReturn    : ReturnTypes
    )                  : EnvelopeIndex;
    (*
     * This procedure builds a customized envelope for the specified
     * conditions (thread, importerObject, and afterReturn).
     * It returns a back patch index into the envelope which is used
     * for inserting the previous handler (if afterReturn = callPrevious).
     *
     * The envelope is fairly simple.  It is implemented in
     * a strange way (via an array of bytes).  This makes this procedure
     * difficult to read.  There are three parts to this procedure:
     * pseudo-code, how it would be written in assembly language, and 
     * the InsertXXX instructions.  The InsertXXX instructions should
     * never be modified independently from the assembly language version.
     *
     * CAUTION:
     *     This procedure assumes that Objects are always allocated
     *     at the same OFFSET and just have different SEGMENT values.
     *     If this is not true, then this procedure will not work.
     *
     * INPUT:
     *     envelope,       where to put the data.
     *	   thread,         inserted in the envelope.
     *	   importerObject, what is passed to thread every interrupt.
     * 	   afterReturn,    is there a callPrevious?
     *
     * OUTPUT:
     *     <RETURN>,       the index to insert the callPrevious Address
     *
     * MODIFIED:
     *     envelope is initialized except for (possibly) the callPrevious 
     *     address.
     *)
    VAR
	index : EnvelopeIndex;	(* where we are inserting *)

    PROCEDURE InsertByte( 
	byte : SysTypes.Card
	);
	BEGIN (* InsertByte *)

	    envelope[ index ] := SYSTEM.BYTE( CHR( byte ) );
	    INC( index );

	END InsertByte;


    PROCEDURE InsertCard(
        card : SysTypes.Card
        );
	(* This is a little endian machine, so the low byte goes first. *)
	BEGIN (* InsertCard *)

	    envelope[ index ] := SYSTEM.BYTE( CHR( card MOD 100H ) );
	    INC( index );
	    envelope[ index ] := SYSTEM.BYTE( CHR( card DIV 100H ) );
	    INC( index );

	END InsertCard;

    VAR
	backPatchStackCheck   : EnvelopeIndex;  (* to fixup a jump *)
	noStackChangeIndex    : EnvelopeIndex;  (* where to jump to *)

	backPatchPreemptCheck : EnvelopeIndex;	(* to fixup a jump *)
	backPatchReadyCheck   : EnvelopeIndex;	(* to fixup a jump *)
	callPreviousIndex     : EnvelopeIndex;	(* returned for fixing up *)
	tmpAdr                : SYSTEM.ADDRESS; (* Used for computations. *)
	DONTCARE1             : SYSTEM.ADDRESS;
	restoreRegistersIndex : SysTypes.Card;	(* matches pseudo-label *)
    BEGIN (* SetupEnvelope *)

	(*
	 * The basic algorithm is:
	 *	Save registers and preemptionLevel on the current stack top.
	 *	Set the preemptionLevel to firstLevelDisallow.
	 *	IF SS # interruptStack THEN
	 *	    SS := stack.adr.SEGMENT;
	 *	    SP := stackSize;
	 *	Push oldSS and oldSP.
	 *	IF thread # EmptyHandler THEN
	 *	    IF importerObject = DONTCARE THEN
	 *	        just increment the stack pointer.
	 *	    ELSE
	 *	        push the importerObject on the stack.
	 *	    call thread
	 *	IF afterReturn = callPrevious THEN
	 *	    simulate a software interrupt and
	 *	    setup space for call to previous (fixed by Create)
	 *	Restore stack pointer and segment saved on top of stack.
	 * 	IF saved stack is preemptable THEN
	 *          IF running # readyQueue THEN 
	 *		Save stack pointer in running;
	 *	        running := readyQueue;
	 *		Save stack pointer of old running;
	 *		IF LogitechM2V2 AND Debug THEN
	 *		    save logitech values BP, CS, & IP.
	 *		Get stack pointer of readyQueue;
	 *      Restore preemptionLevel and registers from stack top.
	 * 	Return from interrupt
	 *
	 * Note that we don't have to modify the preemption level, because it
	 * is on a per stack basis and the interrupt handler has it permanently
	 * disallowed (see Create).
	 *)

	(* BEGIN Assembly pseudo-code.  This would not assemble, but
	   represents a very close approximation of the real assembly
	   language.  We have to play a lot of games with offsets into
	   records that are best documented by pseudo-names.
	; Save the registers in the current stack top.  IP:CS and flags
	; have already been saved in the correct order.  
	; WARNING: This code must agree with TasksPRIVATE.IntStackTopRec.
	Push	AX			; GETREG( AX, savedAX );
	Push	CX			; GETREG( CX, savedCX );
	Push	DX			; GETREG( DX, savedDX );
	Push	BX			; GETREG( BX, savedBX );
	Push	ES			; GETREG( ES, savedES );
	Push	BP			; GETREG( BP, savedBP );
	Push	SI			; GETREG( SI, savedSI );
	Push	DI			; GETREG( DI, savedDI );
	Push	DS			; GETREG( DS, savedDS );
	Mov	AX, SEG( preemptionLev ); Setup for preemptionLevel access
	Mov	DS, AX			; Now can use offset value
	Push	[OFF(preemptionLevel)]  ; savedPreemptionLevel := preemptionL
	Mov	ax, disallow		; Disallow preemption during handling,
	Mov	[OFF(preemp)], disallow ; because this is an interrupt handler

	; Now we must save the SS:SP into temporary registers while
	; we switch (if necessary) to the interrupt stack.
	Mov	AX, SS			; Save current stack segment.
	Mov	BX, SP			; Save current stack pointer.

	; Now we must switch to the interrupt stack.  We may already
	; be in an interrupt handler so we must compare the segment
	; address of the current stack with that of the interrupt
	; stack to see if they are the same.   If they are not the same,
	; then we must switch to the base of the interrupt stack.
	; Otherwise, we just execute the next interrupt from the current
	; stack.
	Mov	DX, stack.adr.SEGMENT	; Get interrupt stack segment.
	Cmp	AX, DX			; Are we already running on int stack?
	Je	NoStackChange		; Yes, just use the current stack
	Mov	SS, DX			; No, we must switch to the new one.
	Mov	SP, stackSize		; start fresh from the base!

NoStackChange:
	; The old stack is in AX:BX and we must save for later.
	; We are either in a nested interrupt or on a fresh stack.
	; The Segment must be saved first, because it is the way
	; CallHandlerFrame is setup to work.  This is a little 
	; endian machine and we are using a downward growing stack.
	Push	AX			; save the previous stack segment.
	Push	BX			; save the previous stack pointer.

	; In all cases, we should invalidate BP, so that we can 
	; terminate stack traces.  This is used in FindHandlerCallFrame 
	; and post mortem dumps.  Probably could be in an optional
	; section, but there are very few handlers which don't call
	; anything and aren't chained.
	Mov		BP, invalidBP		; Mark stack properly.

	IF thread # EmptyHandler
	    ; We want execute a Modula procedure with Logitech's calling
	    ; conventions.  The call is "thread( importerObject )".  We
	    ; must push on the importerObject (segment first as per Logitech).
	    ; If the importerObject is DONTCARE, then the Creator doesn't
	    ; care what the importerObject is.  We don't push on "DONTCARE",
	    ; but instead just decrement the SP by the size of an address.
	    IF importerObject = DONTCARE 
		Sub	SP, 4		; Push on DONTCARE address parameter.
	    ELSE
		Mov     AX, importerObject.SEG	; Push on SEGMENT first.
		Push 	AX
		Mov	AX, importerObject.OFF	; Push on OFFSET next.
		Push 	AX
	    END ; importerObject
	    Callf	thread			; Call the handler

	    ; Back from the handler.  The guy may have forgotten to
	    ; clear interrupts.  We do this for safety's sake.
	    Cli					; SYSTEM.DISABLE;
	END ; EmptyHandler
	
	; The following code is conditionally assembled on "afterReturn", 
	; because we don't always want interupts to be chained.
	IF afterReturn = callPrevious
	    ; We have to setup for a call to the prevThread which
	    ; is expecting the stack to look like an INT instruction
	    ; (hardware and software are the same).  A Callf is the
	    ; same as an INT except the flags are pushed on the stack first.
	    Pushf			; Set up for INT
	    Callf DONTCARE1		; This will be filled in with
					; the prevThread inside of Create.
	END ; afterReturn

	; We all are done with the interrupt.  Now we must check to see
	; if the current task is preemptable.  The saved SS:SP points
	; to preemptionLevel so all we have to do is restore those
	; registers.  The problem is that SP can't be used as an index
	; register, thus we restore into BP.  This code must
	; agree with the complementary pushes in the save above.
	Pop	BP			; Get saved stack pointer.
	Pop	SS			; Switch back to old stack.
	; The stack is not valid until the restore!

CheckPreemptionLevel:
	; Check to see if the current stack is preemptable.
	; The former preemption level was saved on the top of the stack
	; and SS:BP points to the top of stack so....
	Mov	AX, [BP+00] 		; SETREG( AX, savedPreemptionLevel );
	Cmp	AX, allowPreemption	; Can we preempt?
	Jne	RestoreRegisters	; No, just restore.

CheckReadyQueue:
	; We are preemptable, but are we already the running process?
	; IF readyQueue = running THEN goto RestoreRegisters.
	; We know that both variables are in the same segment (TasksPRIVATE).
	; We only need to compare segment values of the two tasks, because
	; the task addresses are normalized in Alloc for the convenience here.
	Mov	AX, runningAdr.SEGMENT	; WITH TasksPRIVATE.DS DO
	Mov	DS, AX			; Now we can compare directly.
	; This is rather tricky, but we are basically extracting the
	; SEGMENT value contained in readyQueue (which is a Tasks.Object).
	Mov	AX, [readyQueue.OFF+2]  ; Get seg of head of readyQueue.
	Cmp	AX, [runningAdr.OFF+2]  ; Is running the best to run?
	Je	RestoreRegisters	; Yes, go to RestoreRegisters

SwitchRunning:
	; Running is no longer the best to run so we must switch to the
	; head of the readyQueue.  Note that both running and readyQueue
	; are Ready so we don't have to muck with their task states.
	; At this point:
	;    DS points to TasksPRIVATE data segment
	;    AX contains the segment value of the task to be swapped in.
	;    BP points to the top of the current running task.
	;    SS points to the stack of the current running task.
	; We need to save the intStackTop in the stack base which means
	; we must save BP in the offset part and SS in the segment part.  
	; Then we can change the running task.  Finally, we extract the 
	; task stack for the newly executing task.  
	; Important: we do not assume that stackBase.SEG is the same as 
	; intStack.SEG, because we may have been on a different stack
	; from the one specified by stackBase.
	Les 	SI,[runningAdr]		; Get a pointer to running.
@IF LogitechM2V2 AND Debug THEN
	; Save this information in the task record for Logitech 2.0 PMD
	Mov	CX, [BP+offsetSavedBP]  ; CX := intStackTop.ptr^.savedBP
	Mov	ES:[SI+offsetLogiBP],CX ; logitech.BP := CX
	Mov	CX, [BP+offsetSavedCS]  ; CX := intStackTop.ptr^.savedCS
	Mov	ES:[SI+offsetLogiCS],CX ; logitech.CS := CX
	Mov	CX, [BP+offsetSavedIP]  ; CX := intStackTop.ptr^.savedIP
	Mov	ES:[SI+offsetLogiIP],CX ; logitech.IP := CX
@END (* LogitechM2V2 AND Debug *)
	Les	SI,ES:[SI+stackBaseOff]	; Get a pointer to stack base.
	Mov	ES:[SI+intStackOff],BP	; Save the offset of int stack.
	Mov     ES:[SI+intStackOff+2],SS; Save the segment of int stack.
	Mov     [runningAdr.OFF+2], AX	; running.SEG := readyQueue.SEG
	Mov	SI, [readyQueue.OFF]    ; running.OFF := readyQueue.OFF
	Mov     [runningAdr.OFF], SI	; ""
	Mov	DS, AX			; Get pointer to readyQueue
	Lds	SI, [SI+stackBaseOff]	; Get pointer to stack base
	Mov     BP, [SI+intStackOffset]	; Get the savedSP
	Mov     SS, [SI+intStackOffset+2] ; Get the base of the intStack.
@END (* M2V3 *)

RestoreRegisters:
	; We came here from one of three places: CheckPreemptionLevel,
	; CheckReadyQueue, or just fall through from above.  In all three
	; cases, SS:BP points to the IntStackTop with the registers to restore.
	; Note that this code is just he inverse of the operation performed
	; at the beginning of this envelope.  First we restore SP, then
	; preemptionLevel.
	Mov	SP, BP			; restore SP
	Mov	AX, preempAdr.SEGMENT	; Set up for pop of preemptionLevel
	Mov	DS, AX			; Now we can Pop directly.
	Pop	[preempAdr.OFFSET] 	; Reset the proper preemptionLevel
	Pop	DS			; SETREG( DS, savedDS );
	Pop	DI			; SETREG( DI, savedDI );
	Pop	SI			; SETREG( SI, savedSI );
	Pop	BP			; SETREG( BP, savedBP );
	Pop	ES			; SETREG( ES, savedES );
	Pop	BX			; SETREG( BX, savedBX );
	Pop	DX			; SETREG( DX, savedDX );
	Pop	CX			; SETREG( CX, savedCX );
	Pop	AX			; SETREG( AX, savedAX );
	; Alas the interrupt services is finished and we can return
	; to the running task.
	Iret

	 END Pseudo-assembly language 
	 *)

	(* BEGIN Envelope code assembly.
	 * Now the ugly stuff begins.  Comments are inserted only lightly
	 * so that you can take the code and just compare with a side
	 * by side comparison.  There was no better way to document it.
	 *
	 * Sorry, but InsertCard was used to insert sequences of instructions.
	 * This may look confusing at first, but remember this is a little
	 * endian machine, so the byte on the left is inserted after the
	 * byte on the right (for InsertCard).
	 *)
	index := 0;	(* First address to assemble into  *)
	(* Fixed up only if callPrevious *)
	callPreviousIndex := maxEnvelopeSize - 1;  

(* This is used for counting, leave these lines alone:
DO NOT REMOVE THIS FIRST MARK
0
*)

(* Save registers *)
	InsertByte( I8086.Push + SYSTEM.AX );
	InsertByte( I8086.Push + SYSTEM.CX );
	InsertByte( I8086.Push + SYSTEM.DX );
	InsertByte( I8086.Push + SYSTEM.BX );
	InsertByte( 006H );		(* Push ES *)
	InsertByte( I8086.Push + SYSTEM.BP );
	InsertByte( I8086.Push + SYSTEM.SI );
	InsertByte( I8086.Push + SYSTEM.DI );
	InsertByte( 01EH );		(* Push DS *)
	InsertByte( 0B8H );	(* Mov AX, SEG *)
	InsertCard( preemptionLevelAdr.SEGMENT );
	InsertCard( 0D88EH );		(* Mov DS, AX *)
	InsertCard( 036FFH );		(* Push [OFF] *)
	InsertCard( preemptionLevelAdr.OFFSET );
	InsertByte( 0B8H );		(* Mov AX, disallow *)
	InsertCard( TasksPRIVATE.firstLevelDisallow );
	InsertByte( 0A3H );		(* Mov [OFF], AX *)
	InsertCard( preemptionLevelAdr.OFFSET );
(* Save SS:SP *)
	InsertCard( 0D08CH );		(* Mov AX, SS *)
	InsertCard( 0E389H );		(* Mov BX, SP *)
	InsertByte( 0BAH );		(* Mov DX, stack.base.adr.SEGMENT *)
	InsertCard( stack.adr.SEGMENT );
(* Check stack for change *)
	InsertCard( 0D039H );		(* Cmp AX, DX *)
	InsertByte( I8086.Je );
backPatchStackCheck := index; (* FIXED LATER *)
noStackChangeIndex  := 0;     (* just put in a fill for now... *)
	InsertByte( noStackChangeIndex );
	InsertCard( 0D28EH );		(* Mov SS, DX *)
	InsertByte( 0BCH );		(* Mov SP, size *)
	InsertCard( stackSize );
(* NoStackChange: *)
noStackChangeIndex := index;		(* needed for back patch *)
	InsertByte( I8086.Push + SYSTEM.AX );
	InsertByte( I8086.Push + SYSTEM.BX );
	InsertByte( 0BDH ); 		(* Mov BP, invalidBP *)
	InsertCard( TasksPRIVATE.invalidBP );
	IF SYSTEM.ADDRESS( EmptyHandler ) # SYSTEM.ADDRESS( thread ) THEN
(* Set up stack and call *)
	    IF importerObject = DONTCARE THEN
		InsertCard( 0EC83H );	(* Sub SP, 4 *)
		InsertByte( 004H );	(* Size of address *)
	    ELSE
		InsertByte( 0B8H );	(* Mov AX, SEGMENT *)
		InsertCard( importerObject.SEGMENT );
		InsertByte( I8086.Push + SYSTEM.AX );
		InsertByte( 0B8H );	(* Mov AX, OFFSET *)
		InsertCard( importerObject.OFFSET );
		InsertByte( I8086.Push + SYSTEM.AX );
	    END;
	    InsertByte( I8086.CallFarImmediate );
	    InsertAdr( envelope, index, SYSTEM.ADDRESS( thread ) );
(* Back from call *)
	    InsertByte( I8086.Cli );
	END;
	IF afterReturn = callPrevious THEN
	    InsertByte( I8086.Pushf );
	    InsertByte( I8086.CallFarImmediate );
callPreviousIndex := index;
	    InsertAdr( envelope, index, DONTCARE1 );
	END;
(* Restore SS:SP into SS:BP*)
	InsertByte( I8086.Pop + SYSTEM.BP );
	InsertByte( 017H );		(* Pop SS *)
(* CheckPreemptionLevel: *)
	InsertCard( 0468BH );		(* Mov AX, [BP+00] *)
	InsertByte( 000H ); 
	InsertByte( 03DH ); 		(* Cmp AX, allow   *)
	InsertCard( TasksPRIVATE.allowPreemption );
	InsertByte( I8086.Jne );
backPatchPreemptCheck := index;	(* FIXED LATER *)
	restoreRegistersIndex := 0;	(* just put in a fill for now... *)
	InsertByte( restoreRegistersIndex );
(* CheckReadyQueue: *)
	InsertByte( 0B8H );		(* Mov AX, SEGMENT *)
	InsertCard( runningAdr.SEGMENT );
	InsertCard( 0D88EH );		(* Mov DS, AX *)
	InsertByte( 0A1H ); 		(* Mov AX, [OFFSET+2] *)
	InsertCard( readyQueueAdr.OFFSET + 2 );
	InsertCard( 0063BH ); 		(* Cmp AX, [OFFSET+2] *)
	InsertCard( runningAdr.OFFSET + 2 );
	InsertByte( I8086.Je );
backPatchReadyCheck := index;	(* FIXED LATER *)
	restoreRegistersIndex := 0;	(* just put in a fill for now... *)
	InsertByte( restoreRegistersIndex );
(* SwitchRunning: *)
	InsertCard( 036C4H );		(* Les SI,[runningAdr] *)
	InsertCard( runningAdr.OFFSET );
@IF LogitechM2V2 AND Debug THEN
	    InsertCard( 04E8BH );		(* Mov CX, [BP+OFF] *)
	    InsertByte( offsetSavedBP );
	    InsertCard( 08926H );		(* Mov ES:[SI+OFF], CX *)
	    InsertByte( 04CH );	
	    InsertByte( offsetLogitechBP );
	    InsertCard( 04E8BH );		(* Mov CX, [BP+OFF] *)
	    InsertByte( offsetSavedCS );
	    InsertCard( 08926H );		(* Mov ES:[SI+OFF], CX *)
	    InsertByte( 04CH );	
	    InsertByte( offsetLogitechCS );
	    InsertCard( 04E8BH );		(* Mov CX, [BP+OFF] *)
	    InsertByte( offsetSavedIP );
	    InsertCard( 08926H );		(* Mov ES:[SI+OFF], CX *)
	    InsertByte( 04CH );	
	    InsertByte( offsetLogitechIP );
@END (* LogitechM2V2 AND Debug *)
	InsertCard( 0C426H );		(* Les SI,ES:[SI+stackBaseOff] *)
	InsertByte( 074H );		
	InsertByte( offsetStackBase );
	InsertCard( 08926H );		(* Mov ES:[SI+intStackOff],BP *)
	InsertByte( 06CH );
	InsertByte( offsetIntStackTop );
	InsertCard( 08C26H );		(* Mov ES:[SI+intStackOff+2],SS *)
	InsertByte( 054H );
	InsertByte( offsetIntStackTop+2 );
	InsertByte( 0A3H );		(* Mov [OFFSET], AX *)
	InsertCard( runningAdr.OFFSET+2 );
	InsertCard( 0368BH );		(* Mov SI, [OFFSET] *)
	InsertCard( readyQueueAdr.OFFSET );
	InsertCard( 03689H );		(* Mov [OFFSET], SI *)
	InsertCard( runningAdr.OFFSET );
	InsertCard( 0D88EH );		(* Mov DS, AX *)
	InsertCard( 074C5H );		(* Lds SI, [SI+stackBase] *)
	InsertByte( offsetStackBase );
	InsertCard( 06C8BH );		(* Mov BP, [SI+intStack] *)
	InsertByte( offsetIntStackTop );
	InsertCard( 0548EH );		(* Mov SS, [SI+intStack+2] *)
	InsertByte( offsetIntStackTop+2 );
(* RestoreRegisters: *)
restoreRegistersIndex := index;
	InsertCard( 0EC89H ); 		(* Mov SP, BP *)
	InsertByte( 0B8H );		(* Mov AX, SEGMENT *)
	InsertCard( preemptionLevelAdr.SEGMENT );
	InsertCard( 0D88EH ); 		(* Mov DS, AX *)
	InsertCard( 0068FH ); 		(* Pop [OFF] *)
	InsertCard( preemptionLevelAdr.OFFSET );
	InsertByte( 01FH );      	(* Pop DS *)
	InsertByte( I8086.Pop + SYSTEM.DI );
	InsertByte( I8086.Pop + SYSTEM.SI );
	InsertByte( I8086.Pop + SYSTEM.BP );
	InsertByte( 007H );      	(* Pop ES *)
	InsertByte( I8086.Pop + SYSTEM.BX );
	InsertByte( I8086.Pop + SYSTEM.DX );
	InsertByte( I8086.Pop + SYSTEM.CX );
	InsertByte( I8086.Pop + SYSTEM.AX );
(* Return *)
	InsertByte( I8086.Iret );

(* This is used for counting, leave these lines alone:
0+p
DO NOT REMOVE THIS SECOND MARK
*)

	(* 
	 * We provide forward references in our assembler (neato!).
	 * There are a few things we have to patch, but only two we
	 * can really patch.  We don't know the value of prevThread
	 * yet, so we must return that to the caller.
	 * 
	 * The other things are jumps which need to be patched.
	 * Note the 8088 Jump instruction takes
	 * an 8 bit displacement which is added to the IP + 2.
	 * The backPatch indices are IP + 1, so we only need to subtract 1.
	 *)
	index := backPatchStackCheck;
	InsertByte( noStackChangeIndex - ( backPatchStackCheck + 1 ) );

	index := backPatchPreemptCheck; 
	InsertByte( restoreRegistersIndex - ( backPatchPreemptCheck + 1 ) );

	index := backPatchReadyCheck; 
	InsertByte( restoreRegistersIndex - ( backPatchReadyCheck + 1 ) );
	    
	(* Tell Create where to insert value of prevThread *)
	RETURN callPreviousIndex;
	    
    END SetupEnvelope;


TYPE
    (* This is yet another hacker's tool *)
    AdrPtr = RECORD
	CASE BOOLEAN OF
	    TRUE:
		ptr : POINTER TO SYSTEM.ADDRESS;
	    |
	    FALSE:
		adr : SYSTEM.ADDRESS;
	END; 
    END;

CONST
    interruptTableBase = 0;
	(*
	 * On the 8088, the interrupt vector table starts at this segment.
	 *)

PROCEDURE Create( 
    VAR handler        : Object;
	thread         : HandlerProc;
	importerObject : SysTypes.ANYPTR;
	vectorNumber   : SysTypes.Card;
	afterReturn    : ReturnTypes 
    );
    (*
     * Allocates the handler.  Sets up the record and intializes the 
     * envelope with SetupEnvelope.
     * The final set of initialization is installing the handler in 
     * the interrupt vectorNumber specified and saving the previous handler.  
     * This last operation needs to
     * be done in an interrupts disabled section to prevent an
     * interrupt from occuring in the middle of the assignments.
     * Note also that we may have to back patch the previous handler's
     * address into the envelope if the afterReturn is callPrevious.
     *)
    VAR
	vectorAdrPtr      : AdrPtr;		(* needed to set interrupt *)
	callPreviousIndex : EnvelopeIndex;	(* needed for back patching *)
	p		  : Object;
    BEGIN (* Create *)

	Objects.Allocate( objectMgr, handler );
	WITH handler^ DO
	    next 	 := NIL;	(* Just to be kosher *)
	    vector       := vectorNumber;
	    (* prevThread Initialized later *)
	    callPreviousIndex := SetupEnvelope( envelope, thread, 
						importerObject, afterReturn );

	    (* 
	     * Set the vectorAdrPtr to point to our interrupt vector.
	     *)
	    WITH vectorAdrPtr.adr DO
		SEGMENT := interruptTableBase;
		OFFSET  := SYSTEM.TSIZE( SYSTEM.ADDRESS ) * vectorNumber;
	    END;

	    SYSTEM.DISABLE;
		IF restored THEN
		    ProgErr.Terminate( createDuringTerminateMsg );
		END;

		(*
		 * We must install the interrupt envelope and replace the
		 * old one in a non-interruptable section.  At the same
		 * time, we insert this handler in the list of handlers
		 * as the most recently allocated handler.
		 *)
		prevThread := vectorAdrPtr.ptr^;
		IF afterReturn = callPrevious THEN
		    InsertAdr( envelope, callPreviousIndex, vectorAdrPtr.ptr^ );
		END;
		vectorAdrPtr.ptr^ := SYSTEM.ADR( envelope );
		IF ( root = NIL ) OR ( root^.vector > vector ) THEN
		    (* Insert at the head of the list *)
		    next := root;
		    root := handler;	
		ELSE
		    p := root;
		    WHILE ( p^.next # NIL ) AND ( p^.next^.vector <= vector ) DO
			p := p^.next;
		    END; (* WHILE *)
		    (* Insert at a position after all previously 
		       installed handlers of same vector number. *)
		    next    := p^.next;
		    p^.next := handler;
		END;
	    SYSTEM.ENABLE;

	END; (* WITH *)
	    
    END Create;


PROCEDURE Destroy( 
    VAR handler : Object 
    );
    (* 
     * First thing to do is deinstall the interrupt vector.   The
     * problem is that it may have been already deinstalled.  If it
     * has been, then we do nothing.  To deinstall, we make sure the
     * the list of handlers is proper and only deinstall if we are
     * the correct vector.  Otherwise, we must change around the
     * queue a bit.  The code is complicated by the fact that anyone
     * can change a vector and they don't have to go through this
     * code.  We try to be careful, but when we don't know what to
     * do, we leave it alone (it is not our problem, hopefully).
     *)
    VAR
	vectorAdrPtr : AdrPtr;		(* needed to clear interrupt *)
	p            : Object;
    BEGIN (* Destroy *)

	IF NOT Objects.IsValid( objectMgr, handler ) THEN
	    RETURN;
	END;

	WITH handler^ DO
	    (* 
	     * Set the vectorAdrPtr to point to our interrupt vector.
	     *)
	    WITH vectorAdrPtr.adr DO
		SEGMENT := interruptTableBase;
		OFFSET  := SYSTEM.TSIZE( SYSTEM.ADDRESS ) * vector;
	    END;

	    (* deinstall the interrupt vector *)
	    SYSTEM.DISABLE;	

		(* Don't bother if Restore interrupts has been called. *)
		IF NOT restored THEN
		    (* 
		     * If there is a next handler with the same vector
		     * number, then we must tell him that we are gone,
		     * that is, the next's previous thread should be
		     * us.  If it isn't, then we terminate, because somebody
		     * is fooling around.  If we are supposed to be the
		     * last installed and we aren't the right vector,
		     * then someone else has played games with the interrupt
		     * vector and we want to know about it.
		     *)
		    IF ( next # NIL ) AND ( next^.vector = vector ) THEN
			IF next^.prevThread # SYSTEM.ADR( envelope ) THEN
			    ProgErr.Terminate( destroyConfusedMsg );
			END;
			(* Tell the guy who the "real" previous is *)
			next^.prevThread := prevThread;

		    ELSIF vectorAdrPtr.ptr^ = SYSTEM.ADR( envelope ) THEN
			vectorAdrPtr.ptr^ := prevThread;
		    ELSE
			ProgErr.Terminate( destroyConfusedMsg );
		    END;

		    (*  
		     * Delete from the list and blow up if not in the list.
		     *)
		    IF root = handler THEN
			root := next
		    ELSE
			p := root;
			(* Will get a range error if not in the list *)
			WHILE p^.next # handler DO
			    p := p^.next;
			END; (* WHILE *)
			p := next;
		    END;
		END; (* IF NOT restored *)

	    SYSTEM.ENABLE;

	END; (* WITH *)

	Objects.Deallocate( objectMgr, handler );

    END Destroy;

PROCEDURE SetInvalid( 
    VAR handler : Object 
    );
    BEGIN (* SetInvalid *)

	handler := NIL;

    END SetInvalid;

(*
 * Register management is a little complicated, because we must
 * chase down the stack until we find the base frame of the handler
 * to get access to the pushed on records.  This record defines
 * the call frame for the handler.  Other types of frames (short
 * calls for example) are supported for returnIP and previousBP only.
 * We chase down the stack until the previousBP is equal to invalidBP.
 * This will always be the call frame of the current interrupt.
 *
 * NOTE: there is tight coupling between the operation of this procedure
 *       and the code inside SetEnvelope.  The location of the savedIntStackTop
 *       must have been pushed and the initial BP for a Handler invocation
 * 	 must be invalidBP.
 *)
TYPE
    (*$A-*)
    HandlerCallFrameRec = RECORD
	previousBP       : TasksPRIVATE.Register16;
	returnIP         : TasksPRIVATE.Register16;
	returnCS         : TasksPRIVATE.Register16;
	importerObject   : SysTypes.ANYPTR;
	savedIntStackTop : TasksPRIVATE.IntStackTop;
    END;
    (*$A=*)

    HandlerCallFrame   = RECORD
	CASE BOOLEAN OF
	    TRUE:
		ptr : POINTER TO HandlerCallFrameRec; 	(* to access stack *)
	    |
	    FALSE:
		adr : SYSTEM.ADDRESS;		(* to change segment & offset*)
	END;
    END; (* HandlerCallFrame *)


PROCEDURE FindHandlerCallFrame( 
    VAR callFrame : HandlerCallFrame 
    );
    (*
     * Verifies that the current caller is an interrupt handler (if Assert).
     * Searches down the stack until the previousBP is invalidBP and then
     * returns.
     *)
    BEGIN (* FindHandlerCallFrame *)

	(* Get the current stack frame *)
	WITH callFrame.adr DO
	    SYSTEM.GETREG( SYSTEM.SS, SEGMENT );
	    SYSTEM.GETREG( SYSTEM.BP, OFFSET );
	END; (* WITH *)

	(* We know that the first frame is not the right one *)
	REPEAT  
	    callFrame.adr.OFFSET := callFrame.ptr^.previousBP;
	UNTIL callFrame.ptr^.previousBP = TasksPRIVATE.invalidBP;

    END FindHandlerCallFrame;


PROCEDURE GetSavedRegister( 
    toGet : SavedRegisters 
    )     : SysTypes.CARDINAL16;
    (*
     * Find the base stack frame.  Return the specified register.  
     *)
    VAR
	callFrame : HandlerCallFrame;
    BEGIN (* GetSavedRegister *)

	FindHandlerCallFrame( callFrame );

	WITH callFrame.ptr^.savedIntStackTop.ptr^ DO
	    CASE toGet OF 
		AX: RETURN savedAX;
		|
		BX: RETURN savedBX;
		|
		CX: RETURN savedCX;
		|
		DX: RETURN savedDX;
		|
		DI: RETURN savedDI;
		|
		SI: RETURN savedSI;
		|
		BP: RETURN savedBP;
		|
		SP: RETURN callFrame.ptr^.savedIntStackTop.adr.OFFSET;
		|
		IP: RETURN savedIP;
		|
		DS: RETURN savedDS;
		|
		ES: RETURN savedES;
		|
		SS: RETURN callFrame.ptr^.savedIntStackTop.adr.SEGMENT;
		|
		CS: RETURN savedCS;
		|
		flags: RETURN savedFlags;
	    END; (* CASE *)

	END; (* WITH *)

    END GetSavedRegister;


PROCEDURE SetSavedRegister( 
    toSet    : SavedRegisters;
    newValue : SysTypes.CARDINAL16 
    );
    (*
     * Find the base call frame and set the specified register.  
     * Blows up on the invalid registers.
     *)
    VAR
	callFrame : HandlerCallFrame;
    BEGIN (* GetSavedRegister *)

	FindHandlerCallFrame( callFrame );

	WITH callFrame.ptr^.savedIntStackTop.ptr^ DO
	    CASE toSet OF 
		AX: savedAX := newValue;
		|
		BX: savedBX := newValue;
		|
		CX: savedCX := newValue;
		|
		DX: savedDX := newValue;
		|
		DI: savedDI := newValue;
		|
		SI: savedSI := newValue;
		|
		IP: savedIP := newValue;
		|
		DS: savedDS := newValue;
		|
		ES: savedES := newValue;
		|
		flags: savedFlags := newValue;
		ELSE (* SS, SP, BP, IP, CS *)
		    (* 
		     * We don't need to panic, because this is probably
		     * a software interrupt.
		     *)
		    ProgErr.Terminate( illegalRegisterMsg );
	    END; (* CASE *)

	END; (* WITH *)

    END SetSavedRegister;


PROCEDURE BreakHandler( 
    DONTCARE : SysTypes.ANYPTR 
    );
    (*
     * On a ctrl break all of the registers are set properly, so we
     * merely have to set the flag and return.
     *)
    BEGIN (* BreakHandler *)

	TasksPRIVATE.breakReceived := TRUE;
	Tasks.Ready( Tasks.Object( TasksPRIVATE.deathTask ) );

    END BreakHandler;

(*
 * Special interrupt management.
 *)

PROCEDURE RestoreInterrupts;
    (*
     * Resets all interrupt vectors back to the state upon entry to 
     * the program.  We assume that all interrupt handlers are installed
     * by this module.  If they aren't, we won't crash, but there probably
     * will be problems with the other programs code.
     *)
    VAR
	p            : Object;		(* points to current handler *)
	lastVector   : SysTypes.Card;	(* vector# currently being done *)
	vectorAdrPtr : AdrPtr;		(* needed to clear interrupt *)
    BEGIN (* RestoreInterrupts *)

	SYSTEM.CODE( I8086.Pushf );
	SYSTEM.DISABLE;
	    (* Are we getting called twice? *)
	    IF NOT restored THEN
		restored := TRUE;
		p := root;
		lastVector := SysTypes.MAXCard;	(* something invalid *)
		(* 
		 * We may have a list of handlers with the same vector.
		 * We always insert the first unique prevThread.
		 * for a particular vector.  The rest of the
		 * vectors must be skipped, but other than that
		 * we don't care about them.
		 *
		 * We may not want to do this, but it seems like the
		 * only alternative.  If we ever run sub-programs
		 * which load vectors, then we may want to do 
		 * otherwise.
		 *)
		WHILE p # NIL DO
		    WITH p^ DO
			(* Only do replacement if we haven't replaced already *)
			IF lastVector # vector THEN
			    (* Oldest handler has "best" value *)
			    lastVector := vector;
			    (* Now replace the vector *)
			    WITH vectorAdrPtr.adr DO
				SEGMENT := interruptTableBase;
				OFFSET  := SYSTEM.TSIZE( SYSTEM.ADDRESS ) 
						* vector;
			    END; (* WITH *)
			    vectorAdrPtr.ptr^ := prevThread;
			END;
			p := next;
		    END; (* WITH *)

		END; (* WHILE *)

	    END; (* IF NOT restored *)

	SYSTEM.CODE( I8086.Popf );  

    END RestoreInterrupts;

VAR
    biosCtrlBreakHandler : Object;	(* Handles BIOS ctrl-break *)
    criticalErrorHandler : Object;	(* Handles DOS critical error *)
    dosCtrlBreakHandler  : Object;	(* DOS ctrl-break  *)
    keyboardHandler      : Object;	(* BIOS keyboard *)

PROCEDURE Terminate( 
    mode : SysTypes.ANYPTR
    );
    (*
     * Only destroy the special interrupts handler when we are
     * terminating normally.  Tasks has already called RestoreInterrupts.
     *)
    BEGIN (* Terminate *)
	
	IF mode = Notices.normalTermination THEN
	    Destroy( biosCtrlBreakHandler );
	    Destroy( criticalErrorHandler );
	    Destroy( keyboardHandler );
	    Destroy( dosCtrlBreakHandler );
	    Objects.DestroyManager( objectMgr );
	    SafeStorage.DEALLOCATE( realStack, realStackSize );
	END;

    END Terminate;


VAR
    tmpAdr : SYSTEM.ADDRESS;
    i      : SysTypes.CARDINAL16;


BEGIN (* Interrupts *)

    (* Initialize list of interrupt handlers and how to restore. *)
    root     := NIL;
    restored := FALSE;
    TasksPRIVATE.restoreInterrupts := RestoreInterrupts;

    (* 
     * Allocate the shared interrupt stack before doing anything.
     *)
    SafeStorage.ALLOCATE( realStack, realStackSize );
    stack.adr := realStack;
    stackSize := realStackSize - TasksPRIVATE.AdjustStack( stack.ptr );
    IF ODD( stackSize ) THEN	
	DEC( stackSize );    (* Should be even for performance purposes *)
    END;
    WITH stack.ptr^ DO
	(* Only field we care about is lowestSP *)
	lowestSP := stackSize;
    END;

    Objects.CreateManager( objectMgr, SYSTEM.TSIZE( ObjectRec ),
			   moduleName );

    (*
     * We need to save some constant addresses in TasksPRIVATE, 
     * because they are used in SetupEnvelope.  Note we do a 
     * little assertion check in case Logitech changes the compiler.
     *)
    readyQueueAdr      := SYSTEM.ADR( TasksPRIVATE.readyQueue );
    runningAdr         := SYSTEM.ADR( TasksPRIVATE.running );
    preemptionLevelAdr := SYSTEM.ADR( TasksPRIVATE.preemptionLevel );

    @IF AddressCheck THEN
	IF ( runningAdr.SEGMENT # readyQueueAdr.SEGMENT )
	  OR ( runningAdr.SEGMENT # preemptionLevelAdr.SEGMENT ) THEN
	    ProgErr.Terminate( addressingErrMsg );
	END;
    @END (* AddressCheck *)

    (* Some offsets which we need *)
    WITH TasksPRIVATE.running^ DO
	tmpAdr := TasksPRIVATE.running;
	i := tmpAdr.OFFSET;
	tmpAdr := SYSTEM.ADR( stackBase );
	offsetStackBase := tmpAdr.OFFSET - i;
	i := stackBase.adr.OFFSET;
	tmpAdr := SYSTEM.ADR( stackBase.ptr^.intStackTop );
	offsetIntStackTop := tmpAdr.OFFSET - i;

	@IF LogitechM2V2 AND Debug THEN
	    tmpAdr := TasksPRIVATE.running;
	    i := tmpAdr.OFFSET;
	    (* Get the offsets which we need to save the logi-way *)
	    tmpAdr := SYSTEM.ADR( logitech.BP );
	    offsetLogitechBP  := tmpAdr.OFFSET - i;
	    tmpAdr := SYSTEM.ADR( logitech.CS );
	    offsetLogitechCS  := tmpAdr.OFFSET - i;
	    tmpAdr := SYSTEM.ADR( logitech.IP );
	    offsetLogitechIP  := tmpAdr.OFFSET - i;

	    i := stackBase.ptr^.intStackTop.adr.OFFSET;
	    WITH stackBase.ptr^.intStackTop.ptr^ DO
		tmpAdr := SYSTEM.ADR( savedBP );
		offsetSavedBP := tmpAdr.OFFSET - i;
		tmpAdr := SYSTEM.ADR( savedCS );
		offsetSavedCS := tmpAdr.OFFSET - i;
		tmpAdr := SYSTEM.ADR( savedIP );
		offsetSavedIP := tmpAdr.OFFSET - i;
	    END;
	@END (* LogitechM2V2 AND Debug *)
    END; (* WITH *)

    (*
     * Create the four special interrupt handlers.  When either
     * the crtl break or critical error interrupts are executed,
     * the registers are set by DOS to execute a "retry" for
     * critical error and "ignore" for ctrl break.  This is the
     * exact behaviour that we want.
     *)
    (* Must be installed first *)
    Create( keyboardHandler, EmptyHandler, DONTCARE, 
	    keyboardInt, callPrevious );

    Create( criticalErrorHandler, EmptyHandler, DONTCARE, 
	    DOS.criticalErrorInterrupt, doNotChain );

    Create( biosCtrlBreakHandler, BreakHandler, DONTCARE, 
	    biosCtrlBreakInt, doNotChain );

    Create( dosCtrlBreakHandler, BreakHandler, DONTCARE, 
	    DOS.ctrlBreakExitInterrupt, doNotChain );

    Notices.Register( Notices.GetTerminationNotice(), Terminate );

END Interrupts.
