% Copyright 1988 by Olsen & Associates (O&A), Zurich, Switzerland.
%
%		    All Rights Reserved
%
%
% Permission to use, copy, modify, and distribute this software and its
% documentation for any purpose and without fee is hereby granted,
% provided that the above copyright notice appear in all copies, and
% that both that copyright notice and this permission notice appear in
% supporting documentation, and that all modifications of this software
% or its documentation not made by O&A or its agents are accompanied
% by a prominent notice stating who made the modifications and the date
% of the modifications.
%
% O&A DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE AND ITS
% DOCUMENTATION, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
% FITNESS.  IN NO EVENT SHALL O&A BE LIABLE FOR ANY SPECIAL, INDIRECT OR
% CONSEQUENTIAL DAMAGES, ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
% USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
% OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
% PERFORMANCE OF THIS SOFTWARE OR ITS DOCUMENTATION.
%%%%%%%%%%%%%

\chapter{Implementing Modula-2 Classes}
\label{ClassesChapter}

\section{Purpose}

Object-oriented interfaces allow the declaration of \newterm{subclasses},
which fulfill the objectives of
an interface while permitting the implementation of different methods for 
the operations which define the interface.

A \newterm{class} is a module of implemented operations for 
an object.
Described here is a method by which classes, i.e., more than one
available module of operations for an object, can be implemented in
Modula-2, despite its restriction of only one implementation file per
definition file.

The method explained in this chapter preserves extendibility, by 
permitting the addition of a class to an already existing set of classes.  It
preserves reusability, by allowing the addition of classes without
the modification of
an exported definition module interface.  It contains facilities for
\newterm{configuration}, i.e., ways to initialize 
default classes during
initialization.  Finally, it permits the choice of which class an object can
use when the object is \proc{Created}.

This topic, though important, clearly depends on an understanding of objects
in Modula-2.  Please read Chapter~\ref{ObjectsChapter}.
 before reading this chapter.

\section{Requirements}

The kind of class facility we want should be:
\begin{description}
\item[Reusable]\indent\par
  It should let classes use the same definition module without changing any
  definition module text.

\newpage

\item[Extendible]\indent\par
  It should always allow the addition of a class to those classes which the
  definition module already supports.
\item[Selectable by Name]\indent\par
  A class should have a \newterm{class name}\index{class name} by which it 
  may be selected.
  The class facility should support class names.
\item[Modular]\indent\par
  It should let classes exist in separate modules.
\item[Self-Loading]\indent\par
  If a module supports a class, it should register the class in its
  initialization body so that it registers the class whenever it's
  \code{IMPORT}ed.
\item[Configurable]\indent\par
  It should let a set of initial classes be loaded at initialization time
  without requiring special registration calls by a user.  These classes
  should be loaded before any user selects a class.

  The configuration should also name the \newterm{default class}\index{default
  class} to be
  selected in the absence of a class name.
\end{description}

\section{An Alternative}

Alternative
implementations of classes exist.

For instance, the module \module{NameLists} represents an interesting class
implementation, containing twelve classes generated by combinations of two options:
\begin{description}
 \item[Orderings]\indent\par
  \begin{quote}
   stack lists  (LIFO order); \\
   queue lists  (FIFO order); \\
   sorted lists (sorted by names);
  \end{quote}
 \item[Name Cases]\indent\par
  \begin{quote}
   Case-sensitive names    \\
   Case-insensitive names  \\
   All names coerced to upper case \\
   All names coerced to lower case
  \end{quote}
\end{description}

Since the ordering and name case is set when one calls \proc{Create}, each
(ordering, name case) pair constitutes a separate \module{NameLists} class.

The \module{NameLists} module isn't a good general model for classes, because
its definition module explicitly declares a fixed set of orderings and name
cases.  The \module{NameLists} set of classes cannot be extended without editing
the \module{NameLists} definition module.

Any module which lacks an open-ended method of registering new classes (including a
way to name and refer to new classes) has the same ``problem'' as
\module{NameLists}.

\section{A General Answer}

A general answer implemented in the \library\ has the following elements:
\begin{itemize}
\item
 An \newterm{interface} module\index{interface module}.
 
 Users of a module \code{IMPORT} the interface module.  A ``\code{Create}'' or
 ``\code{Open}'' procedure sets up an object with a class implementation. Later
 calls to the interface, using the object as an argument, refer to this class
 implementation as their executing code.

 Users which utilize but do not register class implementations should
 \code{IMPORT} only this module to do their work.

\item
 A \newterm{registration}\index{registration procedure} and \newterm{core} 
 {\em procedures}\index{core procedure} module.

 The registration procedures let other modules associate a class name
 with the set of procedures which implement the interface exported by the
 interface module.  The core procedures support standard operations
 which the class implementation modules should find useful in implementing the
 interface for themselves.

\item
 A \newterm{configuration} module\index{configuration module}.

 The configuration module contains a \newterm{default}{\em report}\index{default 
 report procedure}
 procedure, which returns the class name of the default class.  The
 module \code{IMPORT}s class implementation modules.

\item
 One or more \module{class} {\em implementation} \index{classimplementation} modules.
 
 Each class implementation module exports a \code{className}\index{className 
 constant}
 constant.  In their implementation bodies, these modules register their
 procedures using the registration and core procedures module.
\end{itemize}

A more detailed examination of each of these modules follows.

\subsection{The Interface Module}\index{interface module}

The interface module should export the only interface which a module not
registering class implementations should ever \code{IMPORT}.
It should contain no data specific to a class implementation.
The interface module should export the following objects.
\begin{description}
\item[Create Class Object]\indent\par
 A create class object is a procedure to create a class object.  In 
 file I/O procedures, this procedure 
 is conventionally called \proc{Open}; elsewhere, it is usually called
 \proc{Create}.
 For now, call it \proc{Create}.  A declaration of \proc{Create}, stripped
 down to its bare essentials, is the following:
\begin{verbatim}
    TYPE
        Object;     (* the class object *)

    PROCEDURE Create(
            VAR object : Object;
            className  : ARRAY OF CHAR 
        );
\end{verbatim}
 
 The class object is usually declared \code{Object}, an opaque type standing
 for a generic object.  See Chapter~\ref{ObjectsChapter} for details.  It 
 is declared
 as a \code{VAR} parameter, because \proc{Create} allocates space for it
 and then assigns the pointer to this space to the parameter.

 The class name is usually declared \code{ARRAY OF CHAR}, so that an arbitrary
 string can be given to a class implementation as its class name.
 
 The class name type used by \proc{Create} should translate
 to an instance of the class name type used by the procedure which registers
 the class implementation.  The use of \code{ARRAY OF CHAR} for
 the class name is not mandatory.

\item[Destroy Class Object]\index{destroy class object}\indent\par
 A destroy class object is a procedure to destroy a class object, i.e., 
 a standard generic object cleanup
 and deallocation procedure.  In file
 I/O procedures, this procedure is conventionally called \proc{Close}; elsewhere, 
 it is usually called \proc{Destroy}.  For now, call it \proc{Destroy}

 The standard destroy operation has the following declaration:
\begin{verbatim}
    PROCEDURE Destroy(
            VAR object : Object
        );
\end{verbatim}

The object is declared as a \code{VAR} parameter so that \proc{Destroy} can
set it to \code{NIL}, the standard value for an invalid pointer.

\item[Operations on Class Object]\indent\par
 Operations on class object are procedures to implement legal operations 
 on the class object.  Each of these
 procedures \newterm{must\/} include a parameter of type \code{Object}, which
 should stand for the object to which the operation is applied.
\end{description}

How do these different procedures work?

\subsubsection{Create Class Object}\index{create class object}

This procedure should
\begin{itemize}
\item
 allocate a class object,
\item
 initialize its shared data components, 
\item
 call the \proc{FindClass}
 procedure in the registration and core procedures module to get a procedure
 which will stamp the object with a particular class implementation, if a class
 name was passed.

 If no class name was passed (i.e., default), use a default procedure of the
 same type returned by the \proc{FindClass} procedure.  The registration and
 core procedures module should export the default procedure, as a procedure
 variable or as a procedure returning this procedure.
\item
 call the procedure which \proc{FindClass} returns, with the allocated object
 as an argument, to stamp it with a class implementation.
\end{itemize}

 A very simple declaration for a create class object\index{create class object}
 procedure follows.
\begin{verbatim}
    CONST
        defaultClassName = "";

    PROCEDURE Create( 
	    VAR object : Object;
            className  : ARRAY OF CHAR 
        );
\end{verbatim}

\subsubsection{Class Object Operations}

The discussion of the registration and core procedures module explains that the
object record has members containing methods.  Each method should perform an
operation which the interface module exports.  The initialization procedure
which \proc{Create} called should have filled each of these members with
methods which are procedure variables.

For any operation other than \proc{Create}, call the appropriate member
of the object structure to perform the operation and return the result to the
caller of the operation.

The \proc{Destroy} procedure is also one of the operations which use methods.

\subsection{The Registration and Core Procedures Module}
\index{registration
procedure}\index{core procedure}

Only modules which implement the operations of the interface module should
\code{IMPORT} the registration and core procedures module.

This module should contain no data specific to a class implementation.

This module contains:
\begin{itemize}
\item
 \newterm{procedure types}, one for each procedure exported by the interface
 module;
\item
 a \newterm{public\/} definition of the class object, whose definition in the
 interface module should be left opaque;
\item
 an {initialize procedure type} having enough arguments so that
 a class implementation module can initialize a class object --- fill it
 with methods, set shared and class-specific data, etc.;
\item
 procedures to register a class name and initialization procedure and to
 get the initialization procedure corresponding to the class name;
\item
 \newterm{core procedures} which perform standard operations for the benefit
 of class implementations;
\item
 a \newterm{default procedure variable}, which contains an initialization
 procedure called when the default class is requested;
\item
 a \newterm{default class name}, obtained from the configuration module.
 It helps in the setting of the default procedure variable.
\end{itemize}

Each of these parts is explained in the following subsections.

\subsubsection{Procedure Types for Operations}

These procedure types should support methods which implement the operations
exported by the interface module.  When the interface module gets a call
to perform an operation, it will call a procedure which fits one of these
procedure types.

\subsubsection{Class Object Definition}\index{class object}

This is a {\em full\/} definition of the class object exported in opaque form
by the interface module.  A typical definition looks like this:

\begin{verbatim}
    TYPE
        Object    = POINTER TO ObjectRec;

        Method    = PROCEDURE( Object, xxx, yyy );
        ...

        ObjectRec = RECORD
            (* methods --- no Create *)
            operation : Method;
            ...

            (* data shared across class implementations *)
            createArg   : xxx;
            internalVar : yyy;

            (* unique implementation-specific data *)
            classBasedInfo : SysTypes.ANYPTR;
        END;
\end{verbatim}

The name ``\code{ObjectRec}'' is a standard name for the data to which an
\code{Object} points.

The \code{ObjectRec} record has three components: 
\begin{itemize}
\item
 Methods.  These are procedure typed members which implement the operations
 defined in the interface module.

 \proc{Create} is not included in the methods contained in \code{ObjectRec},
 since it allocates and initializes the object.
\item
 Data shared across all class implementations.  This can include additional
 arguments passed to \proc{Create} and internal object variables which keep
 track of the current state of the object.

\item
 Data specific to a class implementation.  Since the registration and core
 procedures module can't specify this data, we express it as a generic
 object, which the individual class implementation should fill in.
\end{itemize}

\subsubsection{Initialize Procedure Type}

The initialize procedure type should contain enough information for a procedure
with its parameters to initialize the class object.
 
The module which uses a class implementation should register a procedure
fitting the init procedure type.  This procedure will stamp the object
with its class implementation.  Mostly, this means filling in the methods
in the object with methods from the class implementation.

A very simple declaration for an initialize procedure type follows.
\begin{verbatim}
    TYPE
        InitProcedureType = PROCEDURE(
	    VAR Object
        );
\end{verbatim}

\subsubsection{Registration and FindClass Procedures}\index{registration
procedure}\index{FindClass procedure}

The registration and find class procedures are very simple:
\begin{verbatim}
    PROCEDURE Register(
	    className : ARRAY OF CHAR;
            initProc  : InitProcedureType 
        );

    PROCEDURE FindClass(  
	    className    : ARRAY OF CHAR;
            VAR initProc : InitProcedureType
        );
\end{verbatim}

The \proc{Register} procedure creates a new entry in a table which associates
class names with initialization procedures.

The \proc{FindClass} procedure searches the table to find the initialization 
procedure matching a given class name.

We assume ``deadly'' error semantics whereby, if the class name is not found,
abnormal termination occurs.  Naturally, these procedures could return
success or failure if designed to do so.

\subsubsection{Core Procedures}

Core procedures should help those who use class implementations.

They're entirely optional but should go in the registration module, since
this module serves as the global access point for all class implementations.

They may offer standard ways to perform common operations or standard
ways to get and set state which is shared across implementations.

\subsubsection{The Default Initialization Procedure}

The default initialization procedure should be sent to the interface module when a user
passes the default create name to \proc{Create}.

The registration and core procedures module should initially set the default
initialization procedure to a bootstrap default procedure, which will abnormally
terminate if called.  Later, the default initialization procedure will be set to its
long term value, by means best described with the configuration
module.

\subsubsection{The Default Class Name}\index{default class name}

This is a name which the registration and core procedures module should
obtain by calling the configuration module, described in the next subsection.
 
When \proc{Register} receives this name as its \code{className} parameter to
a call, it should assign its \code{initProc} parameter to the default init
procedure.  With this assignment, the default init procedure gets its long
term value.

The reasoning behind these mechanics is explained in the next section, which
describes the configuration file.

\subsection{The Configuration Module}
\index{configuration module}

The implementation part of the configuration module should be adapted to 
the local environment.  Other class modules need no adaptation at all;
editing can be restricted to the configuration module.  
Neither does the module implementing the default class need to be edited
to notify it in any way
that it is now the default class.

The configuration module should:
\begin{description}
\item[Export Default Class Name]\indent\par
 The configuration module should export a procedure which produces 
 the default class name.
 It should fill in its internal notion of default class name with a
 \code{className} constant, which the module implementing the default
 class should declare as its only export.

\item[Import Class Implementations]\indent\par
 By \code{IMPORT}ing modules which implement class implementations, the
 configuration module will cause their initialization bodies to register
 their class names and initialization procedures with the registration
 and core procedures module.

 In the case of the module which implements the default class, its
 registration will lead to the registration and core procedures module
 filling in its default initialization procedure with the initialization
 procedure which this default class module passes to \proc{Register}.

\end{description}

An advantage of using the configuration module to import the default
class implementation modules is that, since
\begin{quote}
the interface module \code{IMPORT}s the registration and code procedures
module, \\
which \code{IMPORT}s the configuration module, \\
which \code{IMPORT}s the default class implementation module, \\
which \code{IMPORT}s the registration and code procedures module,
\end{quote}
all these modules initialize in tandem with each other, before anyone
\code{IMPORT}ing the interface module calls its \proc{Create} procedure.

This assures that the default class implementation module will trigger
the long-term assignment of a procedure to the default initialization
procedure variable, before anyone initializes and calls the interface module
\proc{Create} procedure.

\subsection{Class Implementation Modules}
\index{class implementation module}

A class implementation module should:
\begin{description}
\item[Export a Class Name]\indent\par

A standard name for this is \code{className}.
\item[Export a \proc{MakeOptions} Procedure]\indent\par

If the class implementation has some special parameters in addition to the
standard parameters offered by the interface module \proc{Create}, it should
compress these parameters into either a generic object or a string.

The export of a \proc{MakeOptions} procedure should let a caller perform this
compression naturally.

\item[Register an Initialization Procedure]\indent\par

Using the registration and core procedures \proc{Register} call, the class
implementation module should register, \newterm{from its initialization body}, an
initialization procedure for objects passed it by the interface module's
\proc{Create} procedure.

This initialization procedure should fill the object in with appropriate
methods, re-initialize shared data parts of the object if necessary, and
set the \code{classBasedInfo} member to a generic object if required.

\end{description}


