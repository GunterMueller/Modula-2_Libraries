module Play3S

	(****************************************************************)
	(*								*)
	(*	This module contains some procedures used in		*)
	(*	playing 3-part music.  Although these could have	*)
	(*	been written in Modula-2 - in fact, I've written a	*)
	(*	Modula-2 version - there's potentially an audible	*)
	(*	gain in note quality from running the processor		*)
	(*	as fast as possible.					*)
	(*								*)
	(*	Programmer:	P. Moylan				*)
	(*	Last edited:	21 March 1995				*)
	(*	Status:		OK					*)
	(*								*)
	(*	NOTE: because this code gets its timing from the	*)
	(*	processor speed, it needs to be "tuned" for the		*)
	(*	processor on which it is to run.  There are two		*)
	(*	changes to make:					*)
	(*	  1.	Adjust the value of the constant TimeScale	*)
	(*		(defined below) to adjust the duration of	*)
	(*		a single note.  The faster the processor,	*)
	(*		the larger TimeScale must be.			*)
	(*	  2.	The numbers in the array StepTable may need	*)
	(*		to be scaled up or down to get the right range	*)
	(*		of frequencies.  The separate program called	*)
	(*		PlayMake can help you generate a new version	*)
	(*		of StepTable.					*)
	(*								*)
	(****************************************************************)

(************************************************************************)
(*			SOME TECHNICAL DETAILS				*)
(*									*)
(* The speaker is controlled by the two low-order bits of port 97.	*)
(* Bit 0 enables the timer output to the speaker, and bit 1 turns the	*)
(* speaker on.  This module does not use the timer, because all that	*)
(* can do is create fixed-frequency square waves, and we want more	*)
(* flexible waveform control.  What we do instead is control the	*)
(* speaker by direct manipulation of bit 1.  By using pulse-width	*)
(* modulation techniques, we achieve the equivalent of 2-bit analogue	*)
(* output.  (We need only 2 bits because we're working with square	*)
(* waves for all voices - see below.)					*)
(*									*)
(* Unlike my other versions of this software, this one does not have	*)
(* a waveform table.  We're using a square wave for each voice.  At	*)
(* each sample time each of the three pointers Ptr1, Ptr2, Ptr3 shows	*)
(* where we're up to in the cycle, and we can use the high-order bit	*)
(* of a pointer to say whether that voice should be at its "off" or	*)
(* "on" value.  Adding three square waves gives only four distinct	*)
(* values that the sum can have, so at each sample time there's a	*)
(* four-way decision about what to send out to the speaker.		*)
(*									*)
(************************************************************************)

extrn Keyboard$KeyPressed
extrn Keyboard$

(************************************************************************)
(*				MODULE DATA				*)
(************************************************************************)

    (* The following constant value controls the note durations.	*)
    (* Make it smaller for a slower processor, or larger for a faster	*)
    (* processor.  The values I've found suitable are about 150 for a   *)
    (* DX2/50, and about 110 for a 33MHz machine.			*)

    TimeScale = 110

(*%T _fdata *)
segment Play3S_DATA (DATA, 28H)
(*%E*)
(*%F _fdata *)
segment _DATA (DATA, 28H)
(*%E*)

    (* Jump table for a case selection in procedure PutOutValue. *)

    JumpTable:	dw  case0, case1, case2, case3

    (* Conversion table: converts a note code to the increment to use	*)
    (* when stepping through a waveform table.  These codes are		*)
    (* interpreted as fixed-point numbers, with the high-order byte	*)
    (* giving the integral part.  The table is generated by a program	*)
    (* called PlayMake.							*)

    StepTable:
	dw	     0,    40,    42,    44,    47,    50,    53,    56
	dw	    59,    63,    67,    71,    75,    79,    84,    89
	dw	    95,   100,   106,   113,   119,   126,   134,   142
	dw	   151,   159,   169,   179,   190,   201,   213,   226
	dw	   239,   253,   269,   285,   302,   319,   339,   359
	dw	   380,   403,   427,   452,   479,   507,   538,   570
	dw	   604,   639,   678,   718,   761,   806,   854,   905
	dw	   958,  1015,  1076,  1140,  1208,  1279,  1356,  1436

    (* For each of the three voices, we have a "step" value, obtained	*)
    (* by looking up the StepTable, and a "pointer", whose value shows	*)
    (* which point of the cycle we've reached for that voice.  The	*)
    (* step and pointer for voice 1 are kept in registers; for the	*)
    (* other voices, we use the following locations.			*)
    (* The current version of this module depends on these variables	*)
    (* being laid out in the order given, since we access these data	*)
    (* sequentially.							*)

    Step2:	dw	0
    Ptr2:	dw	0
    Step3:	dw	0
    Ptr3:	dw	0

    (* Duration of one note. *)

    Duration:	dw	100

    (* Value used to turn the speaker on.  The value to turn it off	*)
    (* is this value minus 2.  Note that the actual value is set during	*)
    (* initialisation of this module.					*)

    OnValue:	db	2

(****************** Pointer to the initialisation code ******************)

(*%T _fdata*)
segment _INIT_DATA_CONST (FAR_DATA, 28H)
(*%E*)
(*%F _fdata*)
segment _CONST (DATA, 28H)
(*%E*)

    public Play3S$:
		(*%T _fcall*)
		dd InitCode
		(*%E*)
		(*%F _fcall*)
		dw InitCode
		(*%E*)
		dw Keyboard$
		(*%T _fdata *)
		dw seg Keyboard$
		(*%E*)
		db 0FFH, 0FFH

(**************** Start of code segment for this module *****************)

(*%T _fcall*)
segment Play3S_TEXT (CODE, 48H)
(*%E*)
(*%F _fcall*)
segment _TEXT (CODE, 48H)
(*%E*)

(************************************************************************)
(* PROCEDURE Delay;							*)
(*									*)
(* Inserts a short delay into the execution.				*)
(************************************************************************)

Delay:
	push ax
	mov ax, 8
DelayLoop:
	dec ax
	jnz DelayLoop
	pop ax
	ret near 0

(************************************************************************)
(* PROCEDURE NoteLoop;							*)
(*									*)
(* Plays one group of three notes, assuming that the Step values have	*)
(* already been computed.						*)
(************************************************************************)

NoteLoop:
	(* ENTRY CONDITIONS:					*)
	(*	AX, BX, CX, DX,					*)
	(*	  SI, BP, ES	free to be used			*)
	(*	DS		selects our data segment	*)
	(*	DI		Step1				*)

	pushf			(* avoid interrupts while	*)
	cli			(*   playing a note		*)

	mov cx, [Duration]	(* initial value for loop counter *)
	mov dx, 97		(* select speaker port		*)
	mov si, Step2		(* point to Step/Ptr area	*)

BigLoop:			(* To allow reasonable values	*)
	push cx			(*   for the variable Duration,	*)
	mov cx, TimeScale	(*   we use two nested loops	*)
InnerLoop:			(*   to count down the timer	*)

	(* REGISTER USAGE IN THIS SECTION.				*)
	(*	AX	temporaries		BX	running total	*)
	(*	CX	loop counter		DX	port number	*)
	(*	SI	local var ptr		DI	Step1		*)
	(*	DS	our data seg		ES	Ptr1		*)

	(* This next section of code moves one sample time forward,	*)
	(* and computes a new level for the output signal.		*)
	(* Note: it's desirable to have an execution time which is	*)
	(* data-independent.  This is why we test the high-order bits	*)
	(* of values by rotating them into the carry bit, rather	*)
	(* than the more obvious approach using conditional branches.	*)
	(* Note also that BH is used in this computation as a place	*)
	(* to hold the constant zero.					*)

	xor bx, bx		(* clear running total		*)
	mov ax, es		(* fetch and increment Ptr1	*)
	add ax, di		(* update Ptr1			*)
	mov es, ax
	rol ax, 1		(* add the high-order bit of	*)
	adc bl, bh		(*   Ptr1 to the running total	*)

	lodsw			(* fetch Step2			*)
	add ax, [si]		(* update Ptr2			*)
	mov [si], ax
	rol ax, 1		(* add the high-order bit of	*)
	adc bl, bh		(*   Ptr2 to the running total	*)
	add si, 2		(* move past Ptr2		*)

	lodsw			(* fetch Step3			*)
	add ax, [si]		(* update Ptr3			*)
	mov [si], ax
	rol ax, 1		(* add the high-order bit of	*)
	adc bl, bh		(*   Ptr3 to the running total	*)

	sub si, 6		(* move back to Step2		*)

	(* We now have a desired level in BX.  This must be translated	*)
	(* into a rectangular wave, to be sent to the speaker, whose	*)
	(* average value is equal to the desired level.  Note that we	*)
	(* always finish with the speaker off, to give a known initial	*)
	(* condition at the next sample time.				*)

	shl bx, 1
	mov al, [OnValue]	(* perform a CASE jump based	*)
	jmp [JumpTable][bx]	(*  on the level		*)
case0:
	sub al, 2
	out dx, al ; call near Delay
	out dx, al ; call near Delay
	out dx, al ; call near Delay
	jmp EndCase
case1:
	out dx, al ; call near Delay
	sub al, 2
	out dx, al ; call near Delay
	out dx, al ; call near Delay
	jmp EndCase
case2:
	out dx, al ; call near Delay
	out dx, al ; call near Delay
	sub al, 2
	out dx, al ; call near Delay
	jmp EndCase
case3:
	out dx, al ; call near Delay
	out dx, al ; call near Delay
	out dx, al ; call near Delay
	sub al, 2
	jmp EndCase
EndCase:
	out dx, al

	(* We've now handled one sample of the output waveform.		*)
	(* Repeat this entire operation TimeScale*[Duration] times.	*)

	loop InnerLoop
	pop cx
	loop BigLoop

	popf			(* Restore flags		*)
	ret near 0		(*    and return		*)

(************************************************************************)
(* PROCEDURE Play (VAR (*IN*) A: ARRAY OF BYTE);			*)
(*									*)
(* Plays the music encoded in array A.  The encoding is explained	*)
(* in the comments in the definition module.				*)
(************************************************************************)

public Play3S$Play:

	(* Entry conditions: AX holds the array size, CX:BX holds the	*)
	(* address of the array.  (In some memory models, only CX holds	*)
	(* the array address.)  We ignore the value in AX, relying	*)
	(* instead on an explicit "end of data" sentinel.		*)

	db 60H (* pusha *)
	push ds
	push es

	(*%T _fptr *)
	mov ds, cx		(* Let DS:SI point to user data	*)
	(*%E*)
	mov si, bx
	mov di, seg JumpTable	(* keep a selector for our own	*)
				(*    data segment in DI	*)

MainLoop:
	(*%F _fdata *)
	push ds
	mov ds, di
	(*%E*)
	(*%T _fcall *)
	call far Keyboard$KeyPressed
	(*%E*)
	(*%F _fcall *)
	call near Keyboard$KeyPressed
	(*%E*)
	(*%F _fdata *)
	pop ds
	(*%E*)
	test al, al		(* abort playing if a		*)
	jne Finished		(*   keyboard key is pressed	*)

	lodsb			(* fetch first byte of triple	*)
	cmp al, 64		(* special case?		*)
	jae SpecialCase
	mov bl, al
	lodsb
	mov cl, al		(* not a special case, load	*)
	lodsb			(*   the three data values into	*)
	mov ch, al		(*     BL, CL, CH		*)

	push ds			(* save pointer to user data	*)
	push si

	mov ds, di		(* select our data segment	*)
	mov si, StepTable	(* point to StepTable		*)
	xor bh, bh		(* clear high-order byte of BX	*)

	shl bl, 1		(* table has two bytes/entry	*)
	mov di, [bx][si]	(* put first step value into DI	*)

	mov bl, cl		(* get note2			*)
	shl bl, 1		(* table has two bytes/entry	*)
	mov ax, [bx][si]	(* fetch step value		*)
	mov [Step2], ax		(* store it			*)

	mov bl, ch		(* get note3			*)
	shl bl, 1		(* table has two bytes/entry	*)
	mov ax, [bx][si]	(* fetch step value		*)
	mov [Step3], ax		(* store it			*)

	(* We've now filled in the "Step" values required to	*)
	(* play the three notes.   Play them.			*)

	call near NoteLoop

	mov di, ds		(* save our segment selector	*)
	pop si			(* restore pointer to user data	*)
	pop ds
	jmp MainLoop		(* go and fetch next notes	*)

SpecialCase:
	(* At this point the reserved registers are SI, DI, DS	*)

	cmp al, 252		(* the 252 option is not	*)
	jne Check253		(*  implemented in this version	*)
	lodsw			(* skip over the data		*)
	jmp MainLoop
Check253:
	cmp al, 253		(* value of 253 means scale	*)
	jne Check254		(*   the duration		*)
	lodsw			(* fetch the two scale factors	*)
	mov bl, ah		(* put the divisor into BX	*)
	xor ah, ah		(* and the multiplier into AX	*)
	mov bh, ah
	push ds
	mov ds, di		(* select our data segment	*)
	mul word [Duration]	(* multiply Duration by first	*)
	div bx			(*   factor and then divide it	*)
	mov [Duration], ax	(*   by second factor		*)
	pop ds
	jmp MainLoop
Check254:
	cmp al, 254		(* value of 254 means set	*)
	jne Finished		(*   new absolute duration	*)
	lodsw			(* fetch the duration value	*)
	push ds
	mov ds, di
	mov [Duration], ax	(* store it			*)
	pop ds
	jmp MainLoop

Finished:
	pop es
	pop ds
	db 61H (* popa *)
	(*%T _fcall *)
	ret far 0
	(*%E*)
	(*%F _fcall *)
	ret near 0
	(*%E*)

(************************************************************************)
(*			MODULE INITIALISATION				*)
(************************************************************************)

InitCode:
	(* Gives a value to OnValue.  This module manipulates bit 1 of	*)
	(* port 97, but we want to leave the other bits of that port	*)
	(* undisturbed.  Also sets a default initial value for the note	*)
	(* duration.							*)

	push ds			(* save registers		*)
	push ax
	mov ax, seg JumpTable	(* select our data segment	*)
	mov ds, ax
	in al, 97		(* current contents of port 97	*)
	and al, 0FCH		(* clear the two low order bits *)
	or al, 2		(* then set bit 1		*)
	mov [OnValue], al	(* store the result as OnValue	*)
	mov word [Duration], 100
	pop ax
	pop ds			(* restore registers and return	*)
	(*%T _fcall *)
	ret far 0
	(*%E*)
	(*%F _fcall *)
	ret near 0
	(*%E*)

(************************************************************************)

end
